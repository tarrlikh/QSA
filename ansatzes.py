'''
Tools for manipulation with ansatzes and Hessian calculations
'''


import numpy as np
import elementaries as el
import itertools

def QSA_paulis(string):
    '''
    Creates a pauli string identifier, corresponding to a QSA YXX string, given the list of positions of paulis in that string.
    '''
    lis=[]
    switch=0
    
    for element in string:
        
        if switch == 1:
            lis+=[[element,1]]
        
        if switch == 0:
            lis+=[[element, 2]]
            switch+=1
        

    return(lis)

def k0QSA(k0):
    '''
    Creates a list of pauli string identifiers, corresponding to a k0-quantum subset ansatz. This means that all the QSA gates of order k0 are used. 
    '''    
    #returns subsets of k0 elements from the ordered list of qubits (from 1 to N); 
    #some extra massaging performed, so that a list of lists is returned
    
    string_list=list(map(list,itertools.combinations(list(range(el.number_of_qubits)),k0)))
    
    string_list_with_paulis=list(map(QSA_paulis, string_list))
    
    return(string_list_with_paulis)

def kQSA(k):
    '''
    Creates a list of pauli string identifiers, corresponding to a k-quantum subset ansatz. This means that all the QSA gates of order smaller or equal to k are used. 
    '''    
    lis=[]
    for k0 in range(1,k+1):
        lis+=k0QSA(k0)
    
    return(lis)

def ansatz_operator(list_of_strings, list_of_thetas):
    '''
    Returns an ansatz operator at a given value of parameters.
    
    Inputs a list of pauli string identifiers, which defines an ansatz, and ansatz parameter values list_of_thetas.     
    '''
    operator=el.identity()
    
    for i in range(len(list_of_strings)):
        operator=el.string_iexp(list_of_strings[i], list_of_thetas[i]).dot(operator)
    
    return(operator)

def ansatz_state(list_of_strings, list_of_thetas, in_state_bitstring=np.zeros(el.number_of_qubits, dtype='int'), in_state_prefactor=1):
    '''
    Returns a quantum state, generated by an ansatz operator at a given value of parameters.
    
    Inputs:
    
    -a list of pauli string identifiers, which defines an ansatz
    -ansatz parameter values list_of_thetas
    -if needed, an initial computational basis state encoded in a bitstring; its complex prefactor
    '''
    
    out_state=el.state_from_bitstring(in_state_bitstring, in_state_prefactor)
    
    for i in range(len(list_of_strings)):
        out_state=el.string_iexp(list_of_strings[i], list_of_thetas[i]).dot(out_state)
    
    return(out_state)

def theta_derivative_computation(list_of_strings, list_of_thetas, modified_in_state_bitstring, modified_in_state_prefactor, theta_modification):
    '''
    Calculates a derivative w.r.t. theta_j of some ansatz-generated state. The resulting state is calculated as an action of the same ansatz on a modified initial state, with modified set of thetas (some thetas are inverted, i.e. changed to minus thetas). To generate proper input of initial data, use theta_derivative_preparation.
    
    list list_of_strings - list of string identifiers corresponding to the ansatz
    
    list list_of_thetas - ansatz parameter values 
    
    int list theta_modification - a list that identifies which thetas have to be inverted during the computation
    
    modified_in_state_bitstring, modified_in_state_prefactor - specifications of a modified initial state
    
    '''   
    
    effective_thetas=list( map( lambda x,y: x*(-1)**y, list_of_thetas, theta_modification) )
    
    return(ansatz_state(list_of_strings, effective_thetas, modified_in_state_bitstring, modified_in_state_prefactor) )


def theta_derivative_preparation(j, list_of_strings, in_state_bitstring=np.zeros(el.number_of_qubits, dtype='int'), in_state_prefactor=1, theta_modification=np.array(None)):
    '''
    Prepares necessary information to calculate a derivative w.r.t. theta_j of some ansatz-generated state. The current implementation assumes ansatzes which only have Ys and Xs in their Pauli strings (i.e. QSA's). 
    
    Output:
    
    int list new_theta_modification - a list that identifies which thetas have to be inverted for the computation
  
    new_in_state_bitstring, new_in_state_prefactor - specifications of a modified initial state
    
    Input: 
    
    integer j - the index number of theta
    
    list list_of_strings - list of string identifiers corresponding to the ansatz
    
    int list theta_modification - a list that identifies which thetas, if any, were to be inverted in preparation of an old state
    
    in_state_bitstring, in_state_prefactor - specifications of an initial state

    '''
    if theta_modification.any()==None:
        theta_modification=np.zeros(len(list_of_strings), dtype='int')
    
#     In what follows, simply in_state_prefactor*=1j would be wrong, since we may have -i*theta in the exponent, because of previous theta inversions.
#     Without this correction, the matrix of state's second derivatives will not be symmetric. 
    
    in_state_prefactor*=1j*((-1)**theta_modification[j])   
    
    new_theta_modification=theta_modification.copy()    
 
    
    #checking, which Paulis anticommute and which commute, and noting down which theta's therefore have to be inverted
    
    for i in range(j):
        for pauli in list_of_strings[i]:
            for ppauli in list_of_strings[j]:
                new_theta_modification[i]=np.mod(new_theta_modification[i]+int((pauli[0]==ppauli[0])&(pauli[1]!=ppauli[1])),2)
    
    (new_in_state_bitstring, new_in_state_prefactor) = el.YXXstring_computational_basis_action(list_of_strings[j],in_state_bitstring,in_state_prefactor)
    
    return(new_in_state_bitstring, new_in_state_prefactor, new_theta_modification)

def hessian_computation(observable, list_of_strings, list_of_thetas, first_derivatives_prepared, second_derivatives_prepared):
    
    state=ansatz_state(list_of_strings, list_of_thetas)
    
    hessian_computed=[[None for i in range(len(list_of_strings))] for j in range(len(list_of_strings))]
    
    for i in range(len(list_of_strings)):
        for j in range(len(list_of_strings)):
            
            data_i=first_derivatives_prepared[i]
            data_j=first_derivatives_prepared[j]
            data_ij=second_derivatives_prepared[i][j]
            
            state_i=theta_derivative_computation(list_of_strings, list_of_thetas, data_i[0], data_i[1], data_i[2])
            state_j=theta_derivative_computation(list_of_strings, list_of_thetas, data_j[0], data_j[1], data_j[2])
            state_ij=theta_derivative_computation(list_of_strings, list_of_thetas, data_ij[0], data_ij[1], data_ij[2])
            
            hess=np.real(state_i.dot(observable.dot(state_j))+state.dot(observable.dot(state_ij)))
            hessian_computed[i][j]=hess
        
    return(np.array(hessian_computed))

def jacobian_computation(observable, list_of_strings, list_of_thetas, first_derivatives_prepared):
    
    state=ansatz_state(list_of_strings, list_of_thetas)
    
    jacobian_computed=[None for i in range(len(list_of_strings))]
    
    for i in range(len(list_of_strings)):
        data_i=first_derivatives_prepared[i]
        state_i=theta_derivative_computation(list_of_strings, list_of_thetas, data_i[0], data_i[1], data_i[2])
        jac=np.real(state.dot(observable.dot(state_i))+state_i.dot(observable.dot(state)))
        jacobian_computed[i]=jac
        
    return(np.array(jacobian_computed))

def hessian_preparation(list_of_strings, in_state_bitstring=np.zeros(el.number_of_qubits, dtype='int'), in_state_prefactor=1):
    
    first_derivatives=[None for i in range(len(list_of_strings))]
    
    for j in range(len(list_of_strings)):
        first_derivatives[j]=(theta_derivative_preparation(j, list_of_strings, in_state_bitstring, in_state_prefactor))
    
    second_derivatives=[[None for i in range(len(list_of_strings))] for j in range(len(list_of_strings))]
    
    for i in range(len(list_of_strings)):
        for j in range(len(list_of_strings)):
            (isb, isp, tm)=theta_derivative_preparation(j, list_of_strings, in_state_bitstring, in_state_prefactor)
            second_derivatives[i][j]=theta_derivative_preparation(i, list_of_strings, isb, isp, tm)
    
    
    return(first_derivatives,second_derivatives)


    